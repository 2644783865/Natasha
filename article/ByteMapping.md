### SByte

- 结构

| 类型 | 第1字节 |
| :---: | :---:|
| byte | 255 |
| bit | 1111 1111 |

<br/>
<br/>

- 最大值:127

| 类型 | 第1字节 |
| :---: | :---:|
| byte | 127 |
| bit | 0111 1111 |

> 最高位留1位以表正负  


<br/>  
<br/>

- 最小值:-128

| 类型 | 第1字节 |
| :---: | :---:|
| byte | 128 |
| bit | 1000 0000 |

> 最小负数的bit做完运算结果等于本身  

<br/>
<br/>  

### Byte

- 结构

| 类型 | 第1字节 |
| :---: | :---:|
| byte | 255 |
| bit | 1111 1111 |

<br/>
<br/>

- 最大值:255

| 类型 | 第1字节 |
| :---: | :---:|
| byte | 255 |
| bit | 1111 1111 |

> 最高位留1位以表正负  


<br/>  
<br/>

- 最小值:0

| 类型 | 第1字节 |
| :---: | :---:|
| byte | 0 |
| bit | 0000 0000 |

> 最小负数的bit做完运算结果等于本身  

<br/>
<br/>

### Int32

- 结构

| 类型 | 第1字节 | 第2字节 | 第3字节 | 第4字节 |
| :---: | :---:| :---: | :---: | :---: |
| byte | 255 | 255 | 255 | 255 |
| bit | 1111 1111 | 1111 1111 | 1111 1111 | 1111 1111 |

<br/>
<br/>

- 最大值:2147483647

| 类型 | 第1字节 | 第2字节 | 第3字节 | 第4字节 |
| :---: | :---:| :---: | :---: | :---: |
| byte | 127 | 255 | 255 | 255 |
| bit | 0111 1111 | 1111 1111 | 1111 1111 | 1111 1111 |

> 最高位留1位以表正负  


<br/>  
<br/>

- 最小值:-2147483648

| 类型 | 第1字节 | 第2字节 | 第3字节 | 第4字节 |
| :---: | :---:| :---: | :---: | :---: |
| byte | 128 | 0 | 0 | 0 |
| bit | 1000 0000 | 0000 0000 | 0000 0000 | 0000 0000 |

> 最小负数的bit做完运算结果等于本身  

<br/>
<br/>

刚才的结构都是按照正常的逻辑顺序来展示的，但实际上在内存的存储中分为大小端，请看案例：  

- Int32案例 -15744016 ：  

| 端类型 | 第1字节 | 第2字节 | 第3字节 | 第4字节 |
| :---: | :---:| :---: | :---: | :---: |
| 案例 | 255 | 15 | 195 | 240 | 
| 大端表示 | 1111 1111 | 0000 1111 | 1100 0011 | 1111 0000 | 
| 小端表示 | 1111 0000 | 1100 0011 | 0000 1111 | 1111 1111 |  

现在普遍机型属于小端，可以用 `BitConverter.IsLittleEndian` 来查看。
我本机上是小端存储，所以Int32的极值表格中的127/128都在第4比特。

